// Generated by generate.sh.
// You may want to edit parse.rustpeg or parse.preamble.rs.
#![allow(non_snake_case, unused)]

#[deriving(PartialEq, Show)]
pub enum Key {
    List,
    Para,
    Plain,
    Text,
    BlockQuote,
    Raw,
    LineBreak,
    Space,
    H1,
    H2,
    H3,
    H4,
    H5,
    H6,
    Terminal
}

impl Key {
    fn from_heading_level(u: uint) -> Key {
        match u {
            1 => H1,
            2 => H2,
            3 => H3,
            4 => H4,
            5 => H5,
            6 => H6,
            _ => unreachable!()
        }
    }

    fn heading_level(&self) -> uint {
        match self {
            &H1 => 1,
            &H2 => 2,
            &H3 => 3,
            &H4 => 4,
            &H5 => 5,
            &H6 => 6,
            _   => unreachable!()
        }
    }
}

pub struct Element {
    pub key: Key,
    pub children: Vec<Element>,
    pub text: Option<String>
}

impl Element {
    fn new(key: Key) -> Element {
        Element {
            key: key,
            children: vec![],
            text: None
        }
    }

    fn new_list(children: Vec<Element>) -> Element {
        Element::new_with_children(List, children)
    }

    fn new_with_children(key: Key, children: Vec<Element>) -> Element {
        Element {
            key: key,
            children: children,
            text: None
        }
    }

    fn new_text(s: &str) -> Element {
        Element {
            key: Text,
            children: vec![],
            text: Some(s.to_string())
        }
    }

    fn put_key(self, key: Key) -> Element {
        Element {
            key: key,
            children: self.children,
            text: self.text
        }
    }

    fn text_as_slice<'a>(&'a self) -> &'a str {
        match self.text {
            Some(ref t) => t.as_slice(),
            None    => ""
        }
    }
}

pub fn html_string_from_element(elt: &Element) -> String {
    let mut s = String::new();
    push_formatted_element(&mut s, elt);
    s
}

fn push_formatted_element(s: &mut String, elt: &Element) {
    match elt.key {
        Space => {
            s.push_str(elt.text_as_slice())
        }
        LineBreak => {
            s.push_str("<br />\n");
        }
        Text => {
            s.push_str(elt.text_as_slice()); // XXX needs escaping
        }
        List => {
            push_formatted_elements(s, &elt.children);
        }
        H1 | H2 | H3 | H4 | H5 | H6 => {
            s.push_str((format!("<h{}>", elt.key.heading_level())).as_slice());
            push_formatted_elements(s, &elt.children);
            s.push_str((format!("</h{}>", elt.key.heading_level())).as_slice());
        }
        Plain => {
            push_formatted_elements(s, &elt.children);
        }
        Para => {
            s.push_str("<p>");
            push_formatted_elements(s, &elt.children);
            s.push_str("</p>");
        }
        BlockQuote => {
            s.push_str("<blockquote>\n");
            push_formatted_elements(s, &elt.children);
            s.push_str("</blockquote>\n");
        }
        Raw => {
            // XXX should have been processed before calling this method
            s.push_str(elt.text_as_slice());
        }
        Terminal => {
        }
    }
}

fn push_formatted_elements(s: &mut String, elts: &Vec<Element>) {
    for elt in elts.iter() {
        push_formatted_element(s, elt);
    }
}
// Generated by rust-peg. Do not edit.
enum ParseResult<T> { Matched(uint, T), Failed, }
struct ParseState {
    max_err_pos: uint,
    expected: ::std::collections::HashSet<&'static str>,
}
impl ParseState {
    fn new() -> ParseState {
        ParseState{max_err_pos: 0,
                   expected: ::std::collections::HashSet::new(),}
    }
    fn mark_failure(&mut self, pos: uint, expected: &'static str) ->
     ParseResult<()> {
        if pos > self.max_err_pos {
            self.max_err_pos = pos;
            self.expected.clear();
        }
        if pos == self.max_err_pos { self.expected.insert(expected); }
        Failed
    }
}
fn slice_eq(input: &str, state: &mut ParseState, pos: uint, m: &'static str)
 -> ParseResult<()> {
    #![inline]
    #![allow(dead_code)]
    let l = m.len();
    if input.len() >= pos + l &&
           input.as_bytes().slice(pos, pos + l) == m.as_bytes() {
        Matched(pos + l, ())
    } else { state.mark_failure(pos, m) }
}
fn any_char(input: &str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    #![inline]
    #![allow(dead_code)]
    if input.len() > pos {
        Matched(input.char_range_at(pos).next, ())
    } else { state.mark_failure(pos, "<character>") }
}
fn pos_to_line(input: &str, pos: uint) -> (uint, uint) {
    let mut remaining = pos;
    let mut lineno: uint = 1;
    for line in input.lines() {
        let line_length = line.len() + 1;
        if remaining < line_length { return (lineno, remaining + 1); }
        remaining -= line_length;
        lineno += 1;
    }
    return (lineno, remaining + 1);
}
fn parse_doc<'input>(input: &'input str, state: &mut ParseState, pos: uint) ->
 ParseResult<Element> {
    parse_block(input, state, pos)
}
fn parse_block<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<Element> {
    {
        let seq_res =
            {
                let mut repeat_pos = pos;
                loop  {
                    let pos = repeat_pos;
                    let step_res = parse_blank_line(input, state, pos);
                    match step_res {
                        Matched(newpos, value) => { repeat_pos = newpos; }
                        Failed => { break ; }
                    }
                }
                Matched(repeat_pos, ())
            };
        match seq_res {
            Matched(pos, _) => {
                {
                    let choice_res = parse_block_quote(input, state, pos);
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => {
                            let choice_res = parse_heading(input, state, pos);
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => {
                                    let choice_res =
                                        parse_para(input, state, pos);
                                    match choice_res {
                                        Matched(pos, value) =>
                                        Matched(pos, value),
                                        Failed =>
                                        parse_plain(input, state, pos),
                                    }
                                }
                            }
                        }
                    }
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_heading<'input>(input: &'input str, state: &mut ParseState,
                         pos: uint) -> ParseResult<Element> {
    parse_atx_heading(input, state, pos)
}
fn parse_atx_inline<'input>(input: &'input str, state: &mut ParseState,
                            pos: uint) -> ParseResult<Element> {
    {
        let seq_res =
            {
                let assert_res = parse_newline(input, state, pos);
                match assert_res {
                    Failed => Matched(pos, ()),
                    Matched(..) => Failed,
                }
            };
        match seq_res {
            Matched(pos, _) => {
                {
                    let seq_res =
                        {
                            let assert_res =
                                {
                                    let seq_res = parse_sp(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    {
                                                        let mut repeat_pos =
                                                            pos;
                                                        loop  {
                                                            let pos =
                                                                repeat_pos;
                                                            let step_res =
                                                                slice_eq(input,
                                                                         state,
                                                                         pos,
                                                                         "#");
                                                            match step_res {
                                                                Matched(newpos,
                                                                        value)
                                                                => {
                                                                    repeat_pos
                                                                        =
                                                                        newpos;
                                                                }
                                                                Failed => {
                                                                    break ;
                                                                }
                                                            }
                                                        }
                                                        Matched(repeat_pos,
                                                                ())
                                                    };
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_sp(input,
                                                                         state,
                                                                         pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    parse_newline(input,
                                                                                  state,
                                                                                  pos)
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                            match assert_res {
                                Failed => Matched(pos, ()),
                                Matched(..) => Failed,
                            }
                        };
                    match seq_res {
                        Matched(pos, _) => {
                            parse_xxx_simple_text(input, state, pos)
                        }
                        Failed => Failed,
                    }
                }
            }
            Failed => Failed,
        }
    }
}
fn parse_atx_start<'input>(input: &'input str, state: &mut ParseState,
                           pos: uint) -> ParseResult<Element> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let choice_res = slice_eq(input, state, pos, "######");
                    match choice_res {
                        Matched(pos, value) => Matched(pos, value),
                        Failed => {
                            let choice_res =
                                slice_eq(input, state, pos, "#####");
                            match choice_res {
                                Matched(pos, value) => Matched(pos, value),
                                Failed => {
                                    let choice_res =
                                        slice_eq(input, state, pos, "####");
                                    match choice_res {
                                        Matched(pos, value) =>
                                        Matched(pos, value),
                                        Failed => {
                                            let choice_res =
                                                slice_eq(input, state, pos,
                                                         "###");
                                            match choice_res {
                                                Matched(pos, value) =>
                                                Matched(pos, value),
                                                Failed => {
                                                    let choice_res =
                                                        slice_eq(input, state,
                                                                 pos, "##");
                                                    match choice_res {
                                                        Matched(pos, value) =>
                                                        Matched(pos, value),
                                                        Failed =>
                                                        slice_eq(input, state,
                                                                 pos, "#"),
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let match_str = input.slice(start_pos, pos);
                        Matched(pos,
                                {
                                    Element::new(Key::from_heading_level(match_str.len()))
                                })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_atx_heading<'input>(input: &'input str, state: &mut ParseState,
                             pos: uint) -> ParseResult<Element> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_atx_start(input, state, pos);
            match seq_res {
                Matched(pos, s) => {
                    {
                        let seq_res = parse_sp(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        {
                                            let mut repeat_pos = pos;
                                            let mut repeat_value = vec!();
                                            loop  {
                                                let pos = repeat_pos;
                                                let step_res =
                                                    parse_atx_inline(input,
                                                                     state,
                                                                     pos);
                                                match step_res {
                                                    Matched(newpos, value) =>
                                                    {
                                                        repeat_pos = newpos;
                                                        repeat_value.push(value);
                                                    }
                                                    Failed => { break ; }
                                                }
                                            }
                                            if repeat_value.len() >= 1u {
                                                Matched(repeat_pos,
                                                        repeat_value)
                                            } else { Failed }
                                        };
                                    match seq_res {
                                        Matched(pos, i) => {
                                            {
                                                let seq_res =
                                                    match {
                                                              let seq_res =
                                                                  parse_sp(input,
                                                                           state,
                                                                           pos);
                                                              match seq_res {
                                                                  Matched(pos,
                                                                          _)
                                                                  => {
                                                                      {
                                                                          let seq_res =
                                                                              {
                                                                                  let mut repeat_pos =
                                                                                      pos;
                                                                                  loop 
                                                                                       {
                                                                                      let pos =
                                                                                          repeat_pos;
                                                                                      let step_res =
                                                                                          slice_eq(input,
                                                                                                   state,
                                                                                                   pos,
                                                                                                   "#");
                                                                                      match step_res
                                                                                          {
                                                                                          Matched(newpos,
                                                                                                  value)
                                                                                          =>
                                                                                          {
                                                                                              repeat_pos
                                                                                                  =
                                                                                                  newpos;
                                                                                          }
                                                                                          Failed
                                                                                          =>
                                                                                          {
                                                                                              break
                                                                                                  ;
                                                                                          }
                                                                                      }
                                                                                  }
                                                                                  Matched(repeat_pos,
                                                                                          ())
                                                                              };
                                                                          match seq_res
                                                                              {
                                                                              Matched(pos,
                                                                                      _)
                                                                              =>
                                                                              {
                                                                                  parse_sp(input,
                                                                                           state,
                                                                                           pos)
                                                                              }
                                                                              Failed
                                                                              =>
                                                                              Failed,
                                                                          }
                                                                      }
                                                                  }
                                                                  Failed =>
                                                                  Failed,
                                                              }
                                                          } {
                                                        Matched(newpos, value)
                                                        => {
                                                            Matched(newpos,
                                                                    Some(value))
                                                        }
                                                        Failed => {
                                                            Matched(pos, None)
                                                        }
                                                    };
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                parse_newline(input,
                                                                              state,
                                                                              pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    {
                                                                        let match_str =
                                                                            input.slice(start_pos,
                                                                                        pos);
                                                                        Matched(pos,
                                                                                {
                                                                                    Element::new_with_children(s.key,
                                                                                                               i)
                                                                                })
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_block_quote<'input>(input: &'input str, state: &mut ParseState,
                             pos: uint) -> ParseResult<Element> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_block_quote_raw(input, state, pos);
            match seq_res {
                Matched(pos, a) => {
                    {
                        let match_str = input.slice(start_pos, pos);
                        Matched(pos,
                                {
                                    Element::new_with_children(BlockQuote,
                                                               vec!(a))
                                })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_block_quote_raw<'input>(input: &'input str, state: &mut ParseState,
                                 pos: uint) -> ParseResult<Element> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let mut repeat_pos = pos;
                    let mut repeat_value = vec!();
                    loop  {
                        let pos = repeat_pos;
                        let step_res =
                            parse_block_quote_raw_chunk(input, state, pos);
                        match step_res {
                            Matched(newpos, value) => {
                                repeat_pos = newpos;
                                repeat_value.push(value);
                            }
                            Failed => { break ; }
                        }
                    }
                    if repeat_value.len() >= 1u {
                        Matched(repeat_pos, repeat_value)
                    } else { Failed }
                };
            match seq_res {
                Matched(pos, a) => {
                    {
                        let match_str = input.slice(start_pos, pos);
                        Matched(pos,
                                {
                                    Element::new_text(a.concat().as_slice()).put_key(Raw)
                                })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_block_quote_raw_chunk<'input>(input: &'input str,
                                       state: &mut ParseState, pos: uint) ->
 ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let seq_res = slice_eq(input, state, pos, ">");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    match slice_eq(input, state, pos, " ") {
                                        Matched(newpos, value) => {
                                            Matched(newpos, Some(value))
                                        }
                                        Failed => { Matched(pos, None) }
                                    };
                                match seq_res {
                                    Matched(pos, _) => {
                                        parse_line(input, state, pos)
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                };
            match seq_res {
                Matched(pos, a) => {
                    {
                        let seq_res =
                            {
                                let mut repeat_pos = pos;
                                let mut repeat_value = vec!();
                                loop  {
                                    let pos = repeat_pos;
                                    let step_res =
                                        {
                                            let seq_res =
                                                {
                                                    let assert_res =
                                                        slice_eq(input, state,
                                                                 pos, ">");
                                                    match assert_res {
                                                        Failed =>
                                                        Matched(pos, ()),
                                                        Matched(..) => Failed,
                                                    }
                                                };
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    {
                                                        let seq_res =
                                                            {
                                                                let assert_res =
                                                                    parse_blank_line(input,
                                                                                     state,
                                                                                     pos);
                                                                match assert_res
                                                                    {
                                                                    Failed =>
                                                                    Matched(pos,
                                                                            ()),
                                                                    Matched(..)
                                                                    => Failed,
                                                                }
                                                            };
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                parse_line(input,
                                                                           state,
                                                                           pos)
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        };
                                    match step_res {
                                        Matched(newpos, value) => {
                                            repeat_pos = newpos;
                                            repeat_value.push(value);
                                        }
                                        Failed => { break ; }
                                    }
                                }
                                Matched(repeat_pos, repeat_value)
                            };
                        match seq_res {
                            Matched(pos, b) => {
                                {
                                    let seq_res =
                                        {
                                            let mut repeat_pos = pos;
                                            let mut repeat_value = vec!();
                                            loop  {
                                                let pos = repeat_pos;
                                                let step_res =
                                                    {
                                                        let start_pos = pos;
                                                        {
                                                            let seq_res =
                                                                parse_blank_line(input,
                                                                                 state,
                                                                                 pos);
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    {
                                                                        let match_str =
                                                                            input.slice(start_pos,
                                                                                        pos);
                                                                        Matched(pos,
                                                                                {
                                                                                    "\n"
                                                                                })
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    };
                                                match step_res {
                                                    Matched(newpos, value) =>
                                                    {
                                                        repeat_pos = newpos;
                                                        repeat_value.push(value);
                                                    }
                                                    Failed => { break ; }
                                                }
                                            }
                                            Matched(repeat_pos, repeat_value)
                                        };
                                    match seq_res {
                                        Matched(pos, c) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Matched(pos,
                                                        {
                                                            let mut strs =
                                                                vec!(a .
                                                                     text_as_slice
                                                                     (  ));
                                                            strs.extend(b.iter().map(|e|
                                                                                         e.text_as_slice()));
                                                            strs.push_all(c.as_slice());
                                                            strs.concat()
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_para<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<Element> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_nonindent_space(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_inlines(input, state, pos);
                        match seq_res {
                            Matched(pos, a) => {
                                {
                                    let seq_res =
                                        {
                                            let mut repeat_pos = pos;
                                            let mut repeat_value = vec!();
                                            loop  {
                                                let pos = repeat_pos;
                                                let step_res =
                                                    parse_blank_line(input,
                                                                     state,
                                                                     pos);
                                                match step_res {
                                                    Matched(newpos, value) =>
                                                    {
                                                        repeat_pos = newpos;
                                                        repeat_value.push(value);
                                                    }
                                                    Failed => { break ; }
                                                }
                                            }
                                            if repeat_value.len() >= 1u {
                                                Matched(repeat_pos, ())
                                            } else { Failed }
                                        };
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Matched(pos,
                                                        { a.put_key(Para) })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_plain<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<Element> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_inlines(input, state, pos);
            match seq_res {
                Matched(pos, a) => {
                    {
                        let match_str = input.slice(start_pos, pos);
                        Matched(pos, { a.put_key(Plain) })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_inlines<'input>(input: &'input str, state: &mut ParseState,
                         pos: uint) -> ParseResult<Element> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let mut repeat_pos = pos;
                    let mut repeat_value = vec!();
                    loop  {
                        let pos = repeat_pos;
                        let step_res =
                            {
                                let choice_res =
                                    {
                                        let seq_res =
                                            {
                                                let assert_res =
                                                    parse_endline(input,
                                                                  state, pos);
                                                match assert_res {
                                                    Failed =>
                                                    Matched(pos, ()),
                                                    Matched(..) => Failed,
                                                }
                                            };
                                        match seq_res {
                                            Matched(pos, _) => {
                                                parse_inline(input, state,
                                                             pos)
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                match choice_res {
                                    Matched(pos, value) =>
                                    Matched(pos, value),
                                    Failed => {
                                        let start_pos = pos;
                                        {
                                            let seq_res =
                                                parse_endline(input, state,
                                                              pos);
                                            match seq_res {
                                                Matched(pos, e) => {
                                                    {
                                                        let seq_res =
                                                            {
                                                                let assert_res =
                                                                    parse_inline(input,
                                                                                 state,
                                                                                 pos);
                                                                match assert_res
                                                                    {
                                                                    Matched(..)
                                                                    =>
                                                                    Matched(pos,
                                                                            ()),
                                                                    Failed =>
                                                                    Failed,
                                                                }
                                                            };
                                                        match seq_res {
                                                            Matched(pos, _) =>
                                                            {
                                                                {
                                                                    let match_str =
                                                                        input.slice(start_pos,
                                                                                    pos);
                                                                    Matched(pos,
                                                                            {
                                                                                e
                                                                            })
                                                                }
                                                            }
                                                            Failed => Failed,
                                                        }
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                }
                            };
                        match step_res {
                            Matched(newpos, value) => {
                                repeat_pos = newpos;
                                repeat_value.push(value);
                            }
                            Failed => { break ; }
                        }
                    }
                    if repeat_value.len() >= 1u {
                        Matched(repeat_pos, repeat_value)
                    } else { Failed }
                };
            match seq_res {
                Matched(pos, a) => {
                    {
                        let seq_res =
                            match parse_endline(input, state, pos) {
                                Matched(newpos, value) => {
                                    Matched(newpos, Some(value))
                                }
                                Failed => { Matched(pos, None) }
                            };
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { Element::new_list(a) })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_inline<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<Element> {
    {
        let choice_res = parse_xxx_simple_text(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => parse_endline(input, state, pos),
        }
    }
}
fn parse_xxx_simple_text<'input>(input: &'input str, state: &mut ParseState,
                                 pos: uint) -> ParseResult<Element> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_xxx_simple_str(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let match_str = input.slice(start_pos, pos);
                        Matched(pos, { Element::new_text(match_str) })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_xxx_simple_str<'input>(input: &'input str, state: &mut ParseState,
                                pos: uint) -> ParseResult<()> {
    {
        let mut repeat_pos = pos;
        let mut repeat_value = vec!();
        loop  {
            let pos = repeat_pos;
            let step_res =
                if input.len() > pos {
                    let ::std::str::CharRange { ch, next } =
                        input.char_range_at(pos);
                    match ch {
                        'a' ...'z' | 'A' ...'Z' | '0' ...'9' =>
                        Matched(next, ()),
                        _ => state.mark_failure(pos, "[a-zA-Z0-9]"),
                    }
                } else { state.mark_failure(pos, "[a-zA-Z0-9]") };
            match step_res {
                Matched(newpos, value) => {
                    repeat_pos = newpos;
                    repeat_value.push(value);
                }
                Failed => { break ; }
            }
        }
        if repeat_value.len() >= 1u {
            Matched(repeat_pos, ())
        } else { Failed }
    }
}
fn parse_nonindent_space<'input>(input: &'input str, state: &mut ParseState,
                                 pos: uint) -> ParseResult<()> {
    {
        let choice_res = slice_eq(input, state, pos, "   ");
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res = slice_eq(input, state, pos, "  ");
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => {
                        let choice_res = slice_eq(input, state, pos, " ");
                        match choice_res {
                            Matched(pos, value) => Matched(pos, value),
                            Failed => slice_eq(input, state, pos, ""),
                        }
                    }
                }
            }
        }
    }
}
fn parse_endline<'input>(input: &'input str, state: &mut ParseState,
                         pos: uint) -> ParseResult<Element> {
    {
        let choice_res = parse_line_break(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let choice_res = parse_terminal_endline(input, state, pos);
                match choice_res {
                    Matched(pos, value) => Matched(pos, value),
                    Failed => parse_normal_endline(input, state, pos),
                }
            }
        }
    }
}
fn parse_normal_endline<'input>(input: &'input str, state: &mut ParseState,
                                pos: uint) -> ParseResult<Element> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_sp(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_newline(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        {
                                            let assert_res =
                                                parse_blank_line(input, state,
                                                                 pos);
                                            match assert_res {
                                                Failed => Matched(pos, ()),
                                                Matched(..) => Failed,
                                            }
                                        };
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let seq_res =
                                                    {
                                                        let assert_res =
                                                            slice_eq(input,
                                                                     state,
                                                                     pos,
                                                                     ">");
                                                        match assert_res {
                                                            Failed =>
                                                            Matched(pos, ()),
                                                            Matched(..) =>
                                                            Failed,
                                                        }
                                                    };
                                                match seq_res {
                                                    Matched(pos, _) => {
                                                        {
                                                            let seq_res =
                                                                {
                                                                    let assert_res =
                                                                        parse_atx_start(input,
                                                                                        state,
                                                                                        pos);
                                                                    match assert_res
                                                                        {
                                                                        Failed
                                                                        =>
                                                                        Matched(pos,
                                                                                ()),
                                                                        Matched(..)
                                                                        =>
                                                                        Failed,
                                                                    }
                                                                };
                                                            match seq_res {
                                                                Matched(pos,
                                                                        _) =>
                                                                {
                                                                    {
                                                                        let seq_res =
                                                                            {
                                                                                let assert_res =
                                                                                    {
                                                                                        let seq_res =
                                                                                            parse_line(input,
                                                                                                       state,
                                                                                                       pos);
                                                                                        match seq_res
                                                                                            {
                                                                                            Matched(pos,
                                                                                                    _)
                                                                                            =>
                                                                                            {
                                                                                                {
                                                                                                    let seq_res =
                                                                                                        {
                                                                                                            let choice_res =
                                                                                                                {
                                                                                                                    let mut repeat_pos =
                                                                                                                        pos;
                                                                                                                    let mut repeat_value =
                                                                                                                        vec!();
                                                                                                                    loop 
                                                                                                                         {
                                                                                                                        let pos =
                                                                                                                            repeat_pos;
                                                                                                                        let step_res =
                                                                                                                            slice_eq(input,
                                                                                                                                     state,
                                                                                                                                     pos,
                                                                                                                                     "=");
                                                                                                                        match step_res
                                                                                                                            {
                                                                                                                            Matched(newpos,
                                                                                                                                    value)
                                                                                                                            =>
                                                                                                                            {
                                                                                                                                repeat_pos
                                                                                                                                    =
                                                                                                                                    newpos;
                                                                                                                                repeat_value.push(value);
                                                                                                                            }
                                                                                                                            Failed
                                                                                                                            =>
                                                                                                                            {
                                                                                                                                break
                                                                                                                                    ;
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                    if repeat_value.len()
                                                                                                                           >=
                                                                                                                           1u
                                                                                                                       {
                                                                                                                        Matched(repeat_pos,
                                                                                                                                ())
                                                                                                                    } else {
                                                                                                                        Failed
                                                                                                                    }
                                                                                                                };
                                                                                                            match choice_res
                                                                                                                {
                                                                                                                Matched(pos,
                                                                                                                        value)
                                                                                                                =>
                                                                                                                Matched(pos,
                                                                                                                        value),
                                                                                                                Failed
                                                                                                                =>
                                                                                                                {
                                                                                                                    let mut repeat_pos =
                                                                                                                        pos;
                                                                                                                    let mut repeat_value =
                                                                                                                        vec!();
                                                                                                                    loop 
                                                                                                                         {
                                                                                                                        let pos =
                                                                                                                            repeat_pos;
                                                                                                                        let step_res =
                                                                                                                            slice_eq(input,
                                                                                                                                     state,
                                                                                                                                     pos,
                                                                                                                                     "-");
                                                                                                                        match step_res
                                                                                                                            {
                                                                                                                            Matched(newpos,
                                                                                                                                    value)
                                                                                                                            =>
                                                                                                                            {
                                                                                                                                repeat_pos
                                                                                                                                    =
                                                                                                                                    newpos;
                                                                                                                                repeat_value.push(value);
                                                                                                                            }
                                                                                                                            Failed
                                                                                                                            =>
                                                                                                                            {
                                                                                                                                break
                                                                                                                                    ;
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                    if repeat_value.len()
                                                                                                                           >=
                                                                                                                           1u
                                                                                                                       {
                                                                                                                        Matched(repeat_pos,
                                                                                                                                ())
                                                                                                                    } else {
                                                                                                                        Failed
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        };
                                                                                                    match seq_res
                                                                                                        {
                                                                                                        Matched(pos,
                                                                                                                _)
                                                                                                        =>
                                                                                                        {
                                                                                                            parse_newline(input,
                                                                                                                          state,
                                                                                                                          pos)
                                                                                                        }
                                                                                                        Failed
                                                                                                        =>
                                                                                                        Failed,
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                            Failed
                                                                                            =>
                                                                                            Failed,
                                                                                        }
                                                                                    };
                                                                                match assert_res
                                                                                    {
                                                                                    Failed
                                                                                    =>
                                                                                    Matched(pos,
                                                                                            ()),
                                                                                    Matched(..)
                                                                                    =>
                                                                                    Failed,
                                                                                }
                                                                            };
                                                                        match seq_res
                                                                            {
                                                                            Matched(pos,
                                                                                    _)
                                                                            =>
                                                                            {
                                                                                {
                                                                                    let match_str =
                                                                                        input.slice(start_pos,
                                                                                                    pos);
                                                                                    Matched(pos,
                                                                                            {
                                                                                                Element::new_text("\n").put_key(Space)
                                                                                            })
                                                                                }
                                                                            }
                                                                            Failed
                                                                            =>
                                                                            Failed,
                                                                        }
                                                                    }
                                                                }
                                                                Failed =>
                                                                Failed,
                                                            }
                                                        }
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_terminal_endline<'input>(input: &'input str, state: &mut ParseState,
                                  pos: uint) -> ParseResult<Element> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_sp(input, state, pos);
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_newline(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let seq_res =
                                        parse_eof(input, state, pos);
                                    match seq_res {
                                        Matched(pos, _) => {
                                            {
                                                let match_str =
                                                    input.slice(start_pos,
                                                                pos);
                                                Matched(pos,
                                                        {
                                                            Element::new(Terminal)
                                                        })
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_line_break<'input>(input: &'input str, state: &mut ParseState,
                            pos: uint) -> ParseResult<Element> {
    {
        let start_pos = pos;
        {
            let seq_res = slice_eq(input, state, pos, "  ");
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_normal_endline(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { Element::new(LineBreak) })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_blank_line<'input>(input: &'input str, state: &mut ParseState,
                            pos: uint) -> ParseResult<()> {
    {
        let seq_res = parse_sp(input, state, pos);
        match seq_res {
            Matched(pos, _) => { parse_newline(input, state, pos) }
            Failed => Failed,
        }
    }
}
fn parse_eof<'input>(input: &'input str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let assert_res = any_char(input, state, pos);
        match assert_res {
            Failed => Matched(pos, ()),
            Matched(..) => Failed,
        }
    }
}
fn parse_sp<'input>(input: &'input str, state: &mut ParseState, pos: uint) ->
 ParseResult<()> {
    {
        let mut repeat_pos = pos;
        loop  {
            let pos = repeat_pos;
            let step_res = parse_spacechar(input, state, pos);
            match step_res {
                Matched(newpos, value) => { repeat_pos = newpos; }
                Failed => { break ; }
            }
        }
        Matched(repeat_pos, ())
    }
}
fn parse_spacechar<'input>(input: &'input str, state: &mut ParseState,
                           pos: uint) -> ParseResult<()> {
    {
        let choice_res = slice_eq(input, state, pos, " ");
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => slice_eq(input, state, pos, "\t"),
        }
    }
}
fn parse_newline<'input>(input: &'input str, state: &mut ParseState,
                         pos: uint) -> ParseResult<()> {
    {
        let choice_res = slice_eq(input, state, pos, "\n");
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = slice_eq(input, state, pos, "\r");
                    match seq_res {
                        Matched(pos, _) => {
                            {
                                let seq_res =
                                    match slice_eq(input, state, pos, "\n") {
                                        Matched(newpos, value) => {
                                            Matched(newpos, Some(value))
                                        }
                                        Failed => { Matched(pos, None) }
                                    };
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let match_str =
                                                input.slice(start_pos, pos);
                                            Matched(pos, { () })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_line<'input>(input: &'input str, state: &mut ParseState, pos: uint)
 -> ParseResult<Element> {
    {
        let start_pos = pos;
        {
            let seq_res = parse_raw_line(input, state, pos);
            match seq_res {
                Matched(pos, a) => {
                    {
                        let match_str = input.slice(start_pos, pos);
                        Matched(pos, { Element::new_text(a.as_slice()) })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_raw_line<'input>(input: &'input str, state: &mut ParseState,
                          pos: uint) -> ParseResult<String> {
    {
        let choice_res =
            parse_non_breaking_chars_and_newline(input, state, pos);
        match choice_res {
            Matched(pos, value) => Matched(pos, value),
            Failed => {
                let start_pos = pos;
                {
                    let seq_res = parse_any_chars(input, state, pos);
                    match seq_res {
                        Matched(pos, a) => {
                            {
                                let seq_res = parse_eof(input, state, pos);
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let match_str =
                                                input.slice(start_pos, pos);
                                            Matched(pos, { a })
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                        Failed => Failed,
                    }
                }
            }
        }
    }
}
fn parse_non_breaking_chars_and_newline<'input>(input: &'input str,
                                                state: &mut ParseState,
                                                pos: uint) ->
 ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let mut repeat_pos = pos;
                    loop  {
                        let pos = repeat_pos;
                        let step_res =
                            {
                                let seq_res =
                                    {
                                        let assert_res =
                                            slice_eq(input, state, pos, "\r");
                                        match assert_res {
                                            Failed => Matched(pos, ()),
                                            Matched(..) => Failed,
                                        }
                                    };
                                match seq_res {
                                    Matched(pos, _) => {
                                        {
                                            let seq_res =
                                                {
                                                    let assert_res =
                                                        slice_eq(input, state,
                                                                 pos, "\n");
                                                    match assert_res {
                                                        Failed =>
                                                        Matched(pos, ()),
                                                        Matched(..) => Failed,
                                                    }
                                                };
                                            match seq_res {
                                                Matched(pos, _) => {
                                                    any_char(input, state,
                                                             pos)
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                    }
                                    Failed => Failed,
                                }
                            };
                        match step_res {
                            Matched(newpos, value) => { repeat_pos = newpos; }
                            Failed => { break ; }
                        }
                    }
                    Matched(repeat_pos, ())
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let seq_res = parse_newline(input, state, pos);
                        match seq_res {
                            Matched(pos, _) => {
                                {
                                    let match_str =
                                        input.slice(start_pos, pos);
                                    Matched(pos, { match_str.to_string() })
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
                Failed => Failed,
            }
        }
    }
}
fn parse_any_chars<'input>(input: &'input str, state: &mut ParseState,
                           pos: uint) -> ParseResult<String> {
    {
        let start_pos = pos;
        {
            let seq_res =
                {
                    let mut repeat_pos = pos;
                    let mut repeat_value = vec!();
                    loop  {
                        let pos = repeat_pos;
                        let step_res = any_char(input, state, pos);
                        match step_res {
                            Matched(newpos, value) => {
                                repeat_pos = newpos;
                                repeat_value.push(value);
                            }
                            Failed => { break ; }
                        }
                    }
                    if repeat_value.len() >= 1u {
                        Matched(repeat_pos, ())
                    } else { Failed }
                };
            match seq_res {
                Matched(pos, _) => {
                    {
                        let match_str = input.slice(start_pos, pos);
                        Matched(pos, { match_str.to_string() })
                    }
                }
                Failed => Failed,
            }
        }
    }
}
pub fn doc<'input>(input: &'input str) -> Result<Element, String> {
    let mut state = ParseState::new();
    match parse_doc(input, &mut state, 0) {
        Matched(pos, value) => { if pos == input.len() { return Ok(value) } }
        _ => { }
    }
    let expected = state.expected.to_string().escape_default();
    Err(format!("Error at {}: Expected {}" , pos_to_line (
                input , state . max_err_pos ) , expected))
}
